{
  const trueBooleanSet = {
    'true': true,
    'yes': true,
    'high': true,
    'on': true,
    'valid': true,
    'ok': true
  }
  const MakeNumber = value => ({ type: 'number', value: Number(value)  })
  const MakeBinary = (left, operator, right) => ({ type: 'binary', left, operator, right })
  const MakeCall = (target, params = []) => ({ type: 'call', target, params })
}

program = statements:(_? @(statement /*/ pragma*/) _)* _? {
  return {
    type: 'program',
    statements,
    trueBooleanSet
  }
}

// --------- STATEMENTS --------- //
statement
  = section
  / monoid
  / ifCase
  / character
  / returnStatement
  / assignment
  / call
  / choice
  / dialogue
  / narration

character = 'character' _? name:string _? 'as' _? target:IDENTIFIER {
  return {
    type: 'character',
    target,
    name
  }
}

ifCase = 'if' _? expr:expression _? block:block or:(_? 'else' @((_ @ifCase) / (_? @block)))? {
  return {
    type: 'if',
    expr,
    block,
    else: or
  }
}

section = 'section' _? target:IDENTIFIER _? block:block {
  return {
    type: 'section',
    target,
    block
  }
}

call = 'call' _? target:name params:(_? 'with' @exprList)? {
  return MakeCall(target, params)
}

assignment
  = 'set' _ target:IDENTIFIER _ 'to' _? value:expression {
    return {
      type: 'assignment',
      target,
      value
    }
  } / 'add' _? value:expression _? 'to' _ target:IDENTIFIER {
    return {
      type: 'assignment',
      target,
      value: MakeBinary({ type: 'name', value: target }, '+', value)
    }
  }

choice = 'choice' title:(_ @(string / name))? _? '{' options:(_? @choiceCase _?)* _? '}' {
  return {
    type: 'choice',
    options,
    title
  }
}

narration = text:string {
  return {
    type: 'narration',
    text
  }
}

dialogue = actor:(name / string) ' '* text:string {
  return {
    type: 'dialogue',
    actor,
    text
  }
}

returnStatement = 'return' _? value:expression {
  return {
    type: 'return',
    value
  }
}

monoid = type:('clear' / 'end' / 'wait' / 'repeat') {
  return {
    type
  }
}

// -- NON-SHARED ATOMS -- //

choiceCase = match:(string / name) _? then:block {
  return {
    type: 'case',
    match,
    then
  }
}

// --------- EXPRESSIONS --------- //

expression = logicExpr

logicExpr = left:compareExpr _ operator:('and'/'or') _ right:logicExpr {
  return MakeBinary(left, operator, right)
} / compareExpr

compareExpr = left:addExpr _? operator:COMPARE_OP _? right:compareExpr {
  return MakeBinary(left, operator, right)
} / addExpr

addExpr = left:mulExpr _? operator:[+-] _? right:addExpr {
  return MakeBinary(left, operator, right)
} / mulExpr

mulExpr = left:expExpr _? operator:[*/] _? right:mulExpr {
  return MakeBinary(left, operator, right)
} / expExpr

expExpr = left:unaryExpr _? operator:('^' / '**') _? right:expExpr {
  return MakeBinary(left, operator, right)
} / unaryExpr

unaryExpr
  = operator:(([!~@'Â¿+-] _?) / (@'not' _)) term:atom {
    return {
      type: 'unary',
      mode: 'prefix',
      operator,
      term
    }
  }
  / term:propertyAccess _? operator:('exists') {
    return {
      type: 'unary',
      mode: 'postfix',
      operator,
      term
    }
  }
  / propertyAccess

propertyAccess "Property access" = left:atom _? "'s" _ right:propertyAccess {
  return MakeBinary(left, operator, right)
} / atom

atom
  = call
  / choice
  / string
  / number
  / nothing
  / boolean
  / name
  / exprWrap
  / tuple

// --------- PARTIALS --------- //
exprWrap = '(' _? @expression _? ')'

exprList = @(_ @expression)+

// --------- ATOMS --------- //

tuple "Tuple literal" = '[' elements:exprList ']' {
  return {
    type: 'tuple',
    elements
  }
}

random "Random expression"
  = 'roll' sides:(@(_ @number))? { return MakeCall({ type: 'name', value: '__rand' }, sides) }
  / 'one' _ 'of' _ choices:exprList { return MakeCall({ type: 'name', value: '__rand' }, choices) }

block "Program block" = '{' p:program '}' {
  return {
    type: 'block',
    statements: p.statements
  }
}

name "Identifier" = value:IDENTIFIER {
  return {
    type: 'name',
    value
  }
}

string = '"' text:(stringRef / stringEmbedExpr / stringText)* '"' {
  return {
    type: 'string',
    text
  }
} / "'" text:$(!_ .)+ {
  return {
    type: 'string',
    text: [text]
  }
}

stringRef = '$' @name

stringEmbedExpr = '$(' _? @expression _? ')'

stringText = e:$(!'"' ([^$] / '\\$'))+ {
  return e
}

number
  = n:$([0-9]+('.'[0-9]+)?) { return MakeNumber(n) }
  / '1st' { return MakeNumber('1') }
  / '2nd' { return MakeNumber('2') }
  / '3rd' { return MakeNumber('3') }
  / n:$([0-9]+) 'th' { return MakeNumber(n) }
  / expr:exprWrap 'th' { return MakeBinary(expr, '-', MakeNumber('1')) }

boolean = b:BOOLEAN {
  const value = b in trueBooleanSet
  return {
    type: 'boolean',
    value
  }
}

nothing = value:('nothing' / '()' / 'void' / 'nil' / 'null' / 'never' / 'emtpy' / 'invalid') {
  return {
    type: 'unit'
  }
}

BOOLEAN = 'true' / 'false' / 'high' / 'low' / 'yes' / 'no' / 'on' / 'off'
IDENTIFIER = $([A-Za-z_][A-Za-z0-9_]*)
NL = '\r\n' / '\n' / '\r'
COMMENT = '#' (!NL .)* NL
BLANK = [ \t\n\r] / COMMENT
_ = BLANK+
COMPARE_OP = '>=' / '>' / '<=' / '<>' / '<' / '=' / 'is' / 'isnt' / 'isn\'t' / 'is not'
