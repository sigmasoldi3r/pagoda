{
  const trueBooleanSet = {
    'true': true,
    'yes': true,
    'high': true,
    'on': true,
    'valid': true,
    'ok': true
  }
}

program = statements:(_? @(statement /*/ pragma*/) _?)* _? {
  return {
    type: 'program',
    statements,
    trueBooleanSet
  }
}

// --------- STATEMENTS --------- //
statement
  = section
  / ifCase
  / character
  / returnStatement
  / assignment
  / call
  / choice
  / dialogue
  / narration

character = 'character' _? name:string _? 'as' _? target:IDENTIFIER {
  return {
    type: 'character',
    target,
    name
  }
}

ifCase = 'if' _? expr:expression _? block:block {
  return {
    type: 'if',
    expr,
    block
  }
}

section = 'section' _? target:IDENTIFIER _? block:block {
  return {
    type: 'section',
    target,
    block
  }
}

call = 'call' _? target:name params:(_? 'with' @(' '+ @expression)+)? {
  return {
    type: 'call',
    target,
    params
  }
}

assignment = 'set' _? target:IDENTIFIER _? 'to' _? value:expression {
  return {
    type: 'assignment',
    target,
    value
  }
}

choice = 'choice' title:(_ @(string / name))? _? '{' options:(_? @choiceCase _?)* _? '}' {
  return {
    type: 'choice',
    options,
    title
  }
}

narration = text:string {
  return {
    type: 'narration',
    text
  }
}

dialogue = actor:(name / string) ' '* text:string {
  return {
    type: 'dialogue',
    actor,
    text
  }
}

returnStatement = 'return' _? value:expression {
  return {
    type: 'return',
    value
  }
}

// -- NON-SHARED ATOMS -- //

choiceCase = match:(string / name) _? then:block {
  return {
    type: 'case',
    match,
    then
  }
}


// --------- EXPRESSIONS --------- //

expression = compareExpr

atom
  = call
  / choice
  / string
  / number
  / nothing
  / boolean
  / name
  / '(' _? @expression _? ')'

compareExpr = left:addExpr _? operator:COMPARE_OP _? right:compareExpr {
  return {
    type: 'binary',
    operator,
    left,
    right
  }
} / addExpr

addExpr = left:mulExpr _? operator:[+-] _? right:addExpr {
  return {
    type: 'binary',
    operator,
    left,
    right
  }
} / mulExpr

mulExpr = left:expExpr _? operator:[*/] _? right:mulExpr {
  return {
    type: 'binary',
    operator,
    left,
    right
  }
} / expExpr

expExpr = left:unaryExpr _? operator:('^' / '**') _? right:expExpr {
  return {
    type: 'binary',
    operator,
    left,
    right
  }
} / unaryExpr

unaryExpr
  = operator:([!~@'Â¿+-] / (@'not' ' ')) _? term:atom {
    return {
      type: 'unary',
      mode: 'prefix',
      operator,
      term
    }
  }
  / term:atom _? operator:('exists') {
    return {
      type: 'unary',
      mode: 'postfix',
      operator,
      term
    }
  }
  / atom

// --------- ATOMS --------- //

block "Program block" = '{' p:program '}' {
  return {
    type: 'block',
    statements: p.statements
  }
}

name "Identifier" = value:IDENTIFIER {
  return {
    type: 'name',
    value
  }
}

string = '"' text:(stringRef / stringEmbedExpr / stringText)* '"' {
  return {
    type: 'string',
    text
  }
}

stringRef = '$' @name

stringEmbedExpr = '$(' _? @expression _? ')'

stringText = e:$(!'"' ([^$] / '$$'))+ {
  return e
}

number = n:$([0-9]+('.'[0-9]+)?) {
  const value = Number(n)
  return {
    type: 'number',
    value
  }
}

boolean = b:BOOLEAN {
  const value = b in trueBooleanSet
  return {
    type: 'boolean',
    value
  }
}

nothing = value:('nothing' / '()' / 'void' / 'nil' / 'null' / 'never' / 'emtpy' / 'invalid') {
  return {
    type: 'unit'
  }
}

BOOLEAN = 'true' / 'false' / 'high' / 'low' / 'yes' / 'no' / 'on' / 'off'
IDENTIFIER = $([A-Za-z_][A-Za-z0-9_]*)
NL = '\r\n' / '\n' / '\r'
COMMENT = '#' (!NL .)* NL
BLANK = [ \t\n\r] / COMMENT
_ = BLANK+
COMPARE_OP = '>=' / '>' / '<=' / '<>' / '<' / '=' / 'is' / 'isnt' / 'isn\'t' / 'is not'
